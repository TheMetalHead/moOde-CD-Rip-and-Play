# Custom 'abcde.conf' file for 'cd-rip-and-or-play.sh'.
#
# Use permissions of 644

# Support for systems with low disk space:
# n:	Default parallelisation (read entire CD in while encoding)
# y:	No parallelisation (rip, encode, rip, encode...)
# Needs to be 'y' on a 1GB pi.
# If 'LOWDISK=y' then 'NOGAP' must be 'n'.
LOWDISK=n

# Activate lame's --nogap option, that allows files found in CDs with no silence
# between songs (such as live concerts) to be encoded without noticeable gaps.
#NOGAP=y

## If 'LOWDISK=y' then 'NOGAP' must be 'n'.
#NOGAP=n

# Do not rip the whole cd into one track.
ONETRACK="n"

# 22 minutes at x8
# 15 minutes at x16
# 10 minutes at x24
# Leave this option blank to automatically use the fastest speed.
#CDSPEEDVALUE="16"			# Multiples of 150kbs

# Define how many encoders to run at once. This makes for huge speedups
# Defaults to 1.
MAXPROCS=2

# 'musicbrainz' has the better tags except it has no genres.
# 'cddb' has the genres but not the better tags.
# The lookup method happens in the specified order.
CDDBMETHOD=musicbrainz,cddb

# 5 is latin1 output and 6 is UTF8 encoding.
CDDBPROTO=6

#HELLOINFO="`whoami`@`hostname`"
HELLOINFO="fred@bloggs"

CDDBUSELOCAL=n
CDDBCOPYLOCAL=n

## Make a local cache of cddb entries and then volunteer to use
## these entries when and if they match the cd:
#CDDBCOPYLOCAL="y"
#CDDBLOCALDIR="/home/pi/.cddb"
#CDDBLOCALRECURSIVE="y"
#CDDBUSELOCAL="y"

# If NOSUBMIT is set to "y", then abcde will never prompt asking if you
# wish to submit your edited cddb file.
NOSUBMIT=y

# The cd ripping program to use.
CDROMREADERSYNTAX=cdparanoia
CDPARANOIA=cdparanoia
CDPARANOIAOPTS="--never-skip=40"

# Defined as "d" when using cdparanoia with an IDE bus and as
# "g" when using cdparanoia with the ide-scsi emulation layer.
CDPARANOIACDROMBUS=d
#CDPARANOIACDROMBUS=g

# Can be: cddb, cue, read, normalize, encode, tag, move, replaygain, playlist, getalbumart, embedalbumart, clean, default
# The default actions that abcde will take.
ACTIONS=cddb,read,encode,getalbumart,embedalbumart,tag,move,clean

# The location of the CD identification program.
CDDISCID=cd-discid

#MKCUE=mkcue
#CUEREADERSYNTAX="mkcue"
#MKCUEOPTS=""

# Remove the wav files after the encoding has finished.
KEEPWAVS=n

PADTRACKS=y				# Makes tracks 01 02 not 1 2

INTERACTIVE=n

MP3ENCODERSYNTAX=lame			# Specify encoder for MP3

LAME=lame				# Path to MP3 encoder
LAMEOPTS='-m j -b 320 --silent'		# Options for MP3. Joint stereo, silent

# Lame options:
# --tt <title>		Title (max 30 chars for version 1 tag)
# --ta <artist>		Artist (max 30 chars for version 1 tag)
# --tl <album>		Album (max 30 chars for version 1 tag)
# --ty <year>		Year of issue (1 to 9999)
# --tc <comment>	User-defined text (max 30 chars for v1 tag, 28 for v1.1)
# --tn <track[/total]>	Track number and (optionally) the total
#			number of tracks on the original recording. (track
#			and total each 1 to 255. just the track number
#			creates v1.1 tag, providing a total forces v2.0).
# --tg <genre>		Genre (name or number in list)
# --ti <file>		AlbumArt (jpeg/png/gif file, v2.3 tag)

# [VBR] Very high quality: HiFi, home, or quiet listening, with best file size
#
# -V 0 (~245 kbps), -V 1 (~225 kbps), -V 2 (~190 kbps) or -V 3 (~175 kbps) are recommended.
#
# These VBR settings will normally produce transparent results. Audible differences between these presets may exist, but are rare.
# [CBR] Very high quality: HiFi, home, or quiet listening, with maximum file size
#
# -b 320 is an alternative to the VBR settings above.
#
# This CBR mode will maximize the MP3's bitrate and overall file size. The extra space may allow for some parts of the audio to be compressed with fewer sacrifices, but to date, no one has produced ABX test results demonstrating that perceived quality is ever better than the highest VBR profiles described above.[2]
# Portable: listening in noisy conditions, lower bitrate, smaller file size
#
# -V 4 (~165 kbps), -V 5 (~130 kbps) or -V 6 (~115 kbps) are recommended.
#
# -V 6 produces an "acceptable" quality, while -V 4 should be close to perceptual transparency.

# Search engine for music related meta data.
GLYRC=glyrc
#GLYRCOPTS="--formats jpg;jpeg"

# -v --verbosity <integer>
#
# The verbosity level that is used by libglyr:
#
#	0 = No output, but fatal errors.
#	1 = Basic warnings.
#	2 = Normal informal output
#	3 = Basic debug output
#	4 = Full debug output

# -i --minsize

CONVERT=convert
ALBUMARTFILE="cover.jpg"
# Can only have one option here of: png, jpeg, tiff or jpg.
ALBUMARTTYPE="jpg"

# By default convert is only called when the image type is different from
# ALBUMARTTYPE, use ALBUMARTALWAYSCONVERT="y" to always call convert
#ALBUMARTALWAYSCONVERT="y"

# Options for convert/ImageMagick commands used by album art processing when available
# For example: CONVERTOPTS="-colorspace RGB -resize 600x600>"
# to make the image RGB and fit inside 600x600 while keeping the aspect ratio
#IDENTIFYOPTS=
#CONVERTOPTS=
#DISPLAYCMDOPTS="-resize 512x512 -title abcde_album_art"

# Implies 'eyeD3'.
ID3TAGV=id3v2.4

EYED3=eyeD3
#EYED3OPTS="--encoding utf16"

EJECT=eject
#EJECTOPTS=""

# If set to "y" will call eject to eject the cdrom from the drive after all tracks have been read.
EJECTCD="y"

CDSPEED=eject
#CDSPEEDOPTS=""



# Comma separated list of output types.
OUTPUTTYPE="mp3"

# Output directory.
# Set by 'pre_read()'.
OUTPUTDIR=""

# Set by 'pre_read()'.
#CDROM="/dev/cdrom"

# The location where the ripped CD information is stored.
# Set by 'pre_read()'.
DISCIDHOMEDIR=""

# Rip to tmpfs (RAM disk) for fastest rips.
# Set by 'pre_read()'.
#WAVOUTPUTDIR="/tmp"
#WAVOUTPUTDIR="/run"
WAVOUTPUTDIR=""

# NOTE: Use single quotes (') for the variables OUTPUTFORMAT, VAOUTPUTFORMAT, PLAYLISTFORMAT and VAPLAYLISTFORMAT.
#
# Decide here how you want the tracks labelled for a standard 'single-artist',
# multi-track encode and also for a multi-track, 'various-artist' encode:
# Allowed variables are OUTPUT, GENRE, ALBUMFILE, ARTISTFILE, TRACKFILE, TRACKNUM, and YEAR.
# TRACKNUM is automatically zero-padded when the number of encoded tracks is higher than 9.
# The dash between TRACKNUM and TRACKFILE is needed otherwise the cover file will be in the wrong directory.
OUTPUTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${TRACKNUM}-${TRACKFILE}'

# The dash between TRACKNUM and TRACKFILE is needed otherwise the cover file will be in the wrong directory.
VAOUTPUTFORMAT='Various Artists/${ALBUMFILE}-${TRACKNUM} ${ARTISTFILE} ${TRACKFILE}'

# Decide here how you want the tracks labelled for a standard 'single-artist',
# single-track encode and also for a single-track 'various-artist' encode.
# (Create a single-track encode with 'abcde -1' from the commandline.)
ONETRACKOUTPUTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${ARTISTFILE} - ${ALBUMFILE}'

VAONETRACKOUTPUTFORMAT='$VAOUTPUTFORMAT'

# Create playlists for single and various-artist encodes.
# I would suggest commenting these out for single-track encoding.
PLAYLISTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${ALBUMFILE}.m3u'
VAPLAYLISTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${ALBUMFILE}.m3u'

# 0, 1 or 2.
# Set by 'pre_read()'.
EXTRAVERBOSE=0



# This function takes out dots preceding the album name, and removes a grab
# bag of illegal characters. It allows spaces, if you do not wish spaces add
# in -e 's/ /_/g' after the first sed command.
mungefilename() {
	echo "$@" | sed -e 's/^\.*//' | tr -d ":><|*/\"'?[:cntrl:]"
###	echo "$@" | sed -e 's/^\.*//' | tr -d ":><|*/\"'?[:cntrl:]" | tr "[:upper:]" "[:lower:]"
}



# VARIANT 1: (works anywhere style)
#
# Translate everything to lowercase
# replace ALL chars that may cause trouble for Linux, Windows and DOS
# with '_' (underscore); remove double underscores; remove leading and
# trailing underscores; recode to flat ASCII. WARNING! You'll likely
# need to install "recode" on your system as an extra package to use
# this.
#
#mungefilename() {
#	echo "$@" | tr [A-Z] [a-z] | \
#			sed "s/[- ,.:\'\/!@#\?\$%\^&()]/_/g" | \
#			sed 's/_[_]*/_/g' | \
#			sed 's/^_*//' | \
#			sed 's/_*$//' | \
#			recode -f iso8859-1..flat
#
# VARIANT 2: (legible style)
#
# Accept all chars, EXCEPT '/' (obvious) or ":" (because eyeD3 cannot
# cope with ":" in pathnames): replace them with " " (space).
# Additionally, replace contiguous spaces with one space; strip
# leading spaces; strip trailing spaces and recode to flat filenames.
#
#mungefilename() {
#      echo "$@" |     sed "s/[:\/]/ /g" | \
#		       sed 's/ [ ]*/ /g' | \
#		       sed 's/^ *//' | \
#		       sed 's/ *$//' | \
#		       recode -f iso8859-1..flat
#}
#
# Custom filename munging specific to track names:
# By default this function will call the mungefilename function.
#mungetrackname() {
#	mungefilename $@
#}
#
# Custom filename munging specific to artist names:
# By default this function will call the mungefilename function.
#mungeartistname() {
#	mungefilename $@
#}
#
# Custom filename munging specific to album names:
# By default this function will call the mungefilename function.
#mungealbumname() {
#	mungefilename $@
#}



# Custom genre munging:
mungegenre() {
##	echo "mungegenre : ${FUNCNAME[1]} : Line ${BASH_LINENO[0]} : '${CDGENRE}'" >> ${LOGFILE}

	# Convert all the genre to lowercase.
	CDGENRE="${CDGENRE,,}"

##	# Uppercase the first character only.
##	CDGENRE="${CDGENRE^}"

	# Uppercase the first character of each word.
	CDGENRE=( $CDGENRE )		# Without quotes
	CDGENRE="${CDGENRE[@]^}"

	DBG_ECHO "Genre: ${CDGENRE}"

	# Return the genre.
	echo "${CDGENRE}"
}



# Custom functions:

get_genre_and_year() {
if [[ -z ${CDGENRE} || -z "CDYEAR" ]]; then
##	echo "${FUNCNAME[1]} : Line ${BASH_LINENO[0]} : '${@}'" >> ${LOGFILE}

	DBG_ECHO "Finding CDGENRE and CDYEAR."

	_COUNTER=1
	while [ $_COUNTER -lt $NUM_CDDB_MATCHES ]; do
		# /run/abcde.520cd708/cddbread.1
		_DATA="${ABCDETEMPDIR}/cddbread.$_COUNTER"

		let _COUNTER=_COUNTER+1

		# If no CDGENRE defined.
		if [ -z "$CDGENRE" ]; then
			_GENRE="$(grep -a ^DGENRE= "$_DATA" | cut -f2- -d= )"

			_GENRE=${_GENRE//$'\r'}		# Remove the carriage return character

			# If found a genre.
			if [ -n "$_GENRE" ]; then
				# Convert all the genre to lowercase.
				_GENRE="${_GENRE,,}"

				#### Uppercase the first character only.
				###_GENRE="${_GENRE^}"

				# Uppercase the first character of each word.
				_GENRE=( $_GENRE )	# Without quotes
				_GENRE="${_GENRE[@]^}"

				DBG_ECHO "Found: ${_GENRE}"

				GENRE="${_GENRE}"
				CDGENRE="${_GENRE}"
			fi
		fi

		# If no CDYEAR defined.
		if [ -z "$CDYEAR" ]; then
			_YEAR="$(grep -a ^DYEAR= "$_DATA" | cut -f2- -d= )"
			_YEAR=${_YEAR//$'\r'}		# Remove the carriage return character

			# If found a year.
			if [ -n "$_YEAR" ]; then
				DBG_ECHO "Found: ${_YEAR}"

				CDYEAR="${_YEAR}"
			fi
		fi

		# If we have the genre and year fields.
		if [[ -n "${CDGENRE}" && -n "${CDYEAR}" ]]; then
			DBG_ECHO "Artist : '${DARTIST}'"
			DBG_ECHO "Album	 : '${DALBUM}'"
			DBG_ECHO "Year	 : '${CDYEAR}'"
			DBG_ECHO "Genre	 : '${GENRE}'"
			DBG_ECHO "Cdgenre: '${CDGENRE}'"

			break
		fi
	done

	 DBG_WCHO "Finding genre and year done..."
fi
}



# Local functions.

ADD_LAST_SLASH() {
	if [[ "/" == "${1: -1}" ]]; then
		# Already added.
		echo "${1}"
	else
		# Add the last slash.
		echo "${1}/"
	fi
}



REMOVE_LAST_SLASH() {
	 echo "${1%/}"
}



DBG_ECHO() {
	if [ "2" -eq "${EXTRAVERBOSE}" ]; then
		echo "${1}" >> ${LOGFILE}
#		_log_debug "${1}"
	fi
}



DBG_LS() {
	if [ "2" -eq "${EXTRAVERBOSE}" ]; then
		ls -la "${1}" >> ${LOGFILE}
	fi
}



# A shell function which is executed before the CDROM is read for the first time, during abcde execution.
# It can be used to:
#	* Close the CD tray using eject -t (if available in eject and supported by your CD device.
#	* Set the CD speed. You can also use the built-in options, but you can also
#		set it here. In Debian, eject -x and cdset -x do the job.
# KEEP IN MIND that executables included in pre_read must be in your $PATH or
# you have to define them with full /path/to/binary
pre_read() {
# These functions are exported by 'cd-rip-and-or-play.sh'.
#
#	_log_log
#	_log_warn
#	_log_debug
#
# These constants used for '_LOG_LEVEL' are exported by 'cd-rip-and-or-play.sh'.
#
#	LOG_LEVEL_NOLOG
#	LOG_LEVEL_FATAL
#	LOG_LEVEL_ERROR
#	LOG_LEVEL_WARN
#	LOG_LEVEL_OK
#	LOG_LEVEL_LOG
#	LOG_LEVEL_DEBUG
#
# These variables are exported by 'cd-rip-and-or-play.sh'.
#
#	_LOG_LEVEL
#	CDROM			# Usually /dev/cdrom
#	RIPPED_MUSIC_OWNER	# 'pi:pi'
#	MUSIC_DIR		# '/var/lib/mpd/music/SDCARD/CD' or '/var/lib/mpd/music/USB/CD'.
#	MUSIC_SUB_DIR		# '' or 'CD'
#	_G_DISCID_DIR		# '/home/pi/Music-CD/.Music CDs Ripped'
#	TEMP_DIR		# '/run'
#	LOGFILE			# '/var/log/${_SCRIPTNAME}.log'



DBG_ECHO ""
DBG_ECHO ""



# 0...6 ie LOG_LEVEL_NOLOG, LOG_LEVEL_FATAL, LOG_LEVEL_ERROR,
#    LOG_LEVEL_WARN, LOG_LEVEL_OK, LOG_LEVEL_LOG, LOG_LEVEL_DEBUG
case ${_LOG_LEVEL} in
	"${LOG_LEVEL_NOLOG}")		EXTRAVERBOSE=0		;;
	"${LOG_LEVEL_FATAL}")		EXTRAVERBOSE=1		;;
	"${LOG_LEVEL_ERROR}")		EXTRAVERBOSE=1		;;
	"${LOG_LEVEL_WARN}")		EXTRAVERBOSE=1		;;
	"${LOG_LEVEL_OK}")		EXTRAVERBOSE=1		;;
	"${LOG_LEVEL_LOG}")		EXTRAVERBOSE=1		;;
	"${LOG_LEVEL_DEBUG}")		EXTRAVERBOSE=2		;;
	*)				EXTRAVERBOSE=0		;;
esac

#EXTRAVERBOSE=2

# This is already exported by 'cd-rip-and-or-play.sh'.
# CDROM=/dev/cdrom
CDROM=$(REMOVE_LAST_SLASH "${CDROM}")

# OUTPUTDIR="/home/pi/Music-CD"
# /var/lib/mpd/music/My CDs
OUTPUTDIR=$(REMOVE_LAST_SLASH "${MUSIC_DIR}")

### Not used.
### CD/
### $(ADD_LAST_SLASH "${MUSIC_SUB_DIR}")

# The location where the ripped CD information is stored.
# DISCIDHOMEDIR="/home/pi/Music-CD/.Music CDs Ripped/"
DISCIDHOMEDIR=$(ADD_LAST_SLASH "${_G_DISCID_DIR}")

# WAVOUTPUTDIR="/run"
WAVOUTPUTDIR=$(REMOVE_LAST_SLASH "${TEMP_DIR}")

### Not used.
### /var/log/cd-rip-and-or-play.log

_log_log "Log..."
_log_warn "Warn..."
_log_debug "Debug..."

_log_log "Log..."
_log_warn "Warn..."
_log_debug "Debug..."

DBG_ECHO "ExtraVerbose:	 ${EXTRAVERBOSE}"
DBG_ECHO "Cdrom:	 ${CDROM}					    # /dev/cdrom"
DBG_ECHO "OutputDir:	 ${OUTPUTDIR}				 # /var/lib/mpd/music/My CDs"
DBG_ECHO "DiscIdHomeDir: ${DISCIDHOMEDIR}	  # /var/lib/mpd/music/My CDs/.Music CDs Ripped/"
DBG_ECHO "WavOutputDir:	 ${WAVOUTPUTDIR}						 # /run"
DBG_ECHO ""



# If the output directory has not been specified.
if [ -z "${OUTPUTDIR}" ]; then
	# Look for the music directory that is specified in mpd.conf.

	DBG_ECHO "Looking in '/etc/mpd.conf' for the music directory."

	# Read the file in row mode and extract each line.
	while IFS= read -r LINE; do
		#  music_directory	"/var/lib/mpd/music"
		_KEY=${LINE% *}
		_VALUE=${LINE##* }

		if [ "${_KEY}" == "music_directory" ]; then
			# Remove the " character from the start and end of the value token.
			_VALUE=${_VALUE#\"}
			_VALUE=${_VALUE%\"}

			# Returns: /var/lib/mpd/music/SDCARD/CD
			OUTPUTDIR="${_VALUE}/SDCARD/CD"
		fi
	done < "/etc/mpd.conf"
fi

# If no music directory found.
if [ -z "${OUTPUTDIR}" ]; then
	DBG_ECHO "ERROR: Cannot find the music directory."

	exit -1
fi

DBG_ECHO "Using music directory: ${OUTPUTDIR}"

# This should not be needed because CDROM has already been defined in 'cd-rip-and-or-play.sh'.
# If the cdrom path has not been defined or cannot find the cdrom path.
if [[ ( -z "${CDROM}" ) || ( ! -e ${CDROM} ) ]]; then
	DBG_ECHO "Searching for the cdrom drive."

	sleep 5			# Does it really need to be this long???

	# Find out which device the CDROM appears as.
	CDROM=/dev/cdrom
	CDPATH=/dev/sr

	if [ -e ${CDPATH}0 ]; then
		CDROM=${CDPATH}0
	fi

	if [ -e ${CDPATH}1 ]; then
		CDROM=${CDPATH}1
	fi
fi

DBG_ECHO "Using CDROM drive: ${CDROM}"
DBG_ECHO ""

chmod 644 "${CDROM}"

sleep 0.5
}



# A shell function which is executed after the CDROM is read (and, if applies, before the CDROM is ejected).
# It can be used to read a TOC from the CDROM, or to try to read the DATA areas from the CD (if any exist).
# KEEP IN MIND that executables included in pre_read must be in your $PATH or you have to define them
# with full /path/to/binary
post_read() {
# NOTE: echo does not work the same as in 'post_encode'.
# You can only echo to a file.

	DBG_ECHO "In post_read"

	DBG_ECHO "Artistfile: ${ARTISTFILE}"
	DBG_ECHO "Albumfile : ${ALBUMFILE}"
	DBG_ECHO "Trackfile : ${TRACKFILE}"		# Empty
	DBG_ECHO "Dartist   : ${DARTIST}"
	DBG_ECHO "Dalbum    : ${DALBUM}"
	DBG_ECHO "Cdyear    : ${CDYEAR}"
	DBG_ECHO "Genre     : ${GENRE}"			# Empty
	DBG_ECHO "Cdgenre   : ${CDGENRE}"		# Empty

	DBG_ECHO "In post_read done..."
}



# A shell function which is executed after the encoding process.
# It can be used to:
#	* Move the resulting directory to another location or over the network.
#	* Compare results with a previously made run, for tests
# KEEP IN MIND that executables included in post_encode must be in your $PATH or
# you have to define them with full /path/to/binary
post_encode() {
if [ -d "${OUTPUTDIR}/${ARTISTFILE}/${ALBUMFILE}" ]; then
	DBG_ECHO ""
	DBG_ECHO ""

# We should be in: /var/lib/mpd/music/My CDs/Metallica/Master Of Puppets

	DBG_ECHO "Changing directory mode to 755"

	chmod 755 "${OUTPUTDIR}/${ARTISTFILE}"
	chmod 755 "${OUTPUTDIR}/${ARTISTFILE}/${ALBUMFILE}"

	DBG_ECHO "Changing directory owner to ${RIPPED_MUSIC_OWNER}"

	chown "${RIPPED_MUSIC_OWNER}" "${OUTPUTDIR}/${ARTISTFILE}"
	chown "${RIPPED_MUSIC_OWNER}" "${OUTPUTDIR}/${ARTISTFILE}/${ALBUMFILE}"

	DBG_ECHO ""
	DBG_ECHO ""
	DBG_ECHO ""

	DBG_ECHO "Outputdir:	${OUTPUTDIR}"		# /var/lib/mpd/music/My CDs
	DBG_ECHO ""
	DBG_ECHO "CDDB discid:	${CDDBDISCID}"		# 520cd708
	DBG_ECHO ""
	DBG_ECHO "Artistfile:	${ARTISTFILE}"		# Metallica
	DBG_ECHO "Albumfile:	${ALBUMFILE}"		# Master Of Puppets
	DBG_ECHO "Trackfile:	${TRACKFILE}"
	DBG_ECHO "Dartist:	${DARTIST}"		# Metallica
	DBG_ECHO "Dalbum:	${DALBUM}"		# Master Of Puppets
	DBG_ECHO "CD year:	${CDYEAR}"		# 1986
	DBG_ECHO "CD genre:	${CDGENRE}"		# Metal
	DBG_ECHO "Genre:	${GENRE}"		# Metal
	DBG_ECHO "Tracks:	${TRACKS}"		# 08
###	DBG_ECHO "Track num:	${TRACKNUM}"
###	DBG_ECHO "Track name:	${TRACKNAME}"
	DBG_ECHO "Track artist: ${TRACKARTIST}"		# Metallica

	DBG_ECHO ""
	DBG_ECHO ""
	DBG_ECHO ""

	# If the disc id directory does not exist, create it.
	# /var/lib/mpd/music/My CDs/.Music CDs Ripped
	if [ ! -d "${DISCIDHOMEDIR}" ]; then
		DBG_ECHO "Creating: ${DISCIDHOMEDIR}"
		DBG_ECHO ""

		# Create the CD disc id playlist directory.
		mkdir "${DISCIDHOMEDIR}"

		chmod 755 "${DISCIDHOMEDIR}"

		chown "${RIPPED_MUSIC_OWNER}" "${DISCIDHOMEDIR}"
	fi

	# /var/lib/mpd/music/My CDs/.Music CDs Ripped/520cd708 - Metallica - Master Of Puppets
	TARGETDISCIDFILE="${DISCIDHOMEDIR}${CDDBDISCID} - ${ARTISTFILE} - ${ALBUMFILE}"

	DBG_ECHO "Creating the ripped disc id file: ${TARGETDISCIDFILE}"

	touch "${TARGETDISCIDFILE}"

	chmod 644 "${TARGETDISCIDFILE}"

	chown "${RIPPED_MUSIC_OWNER}" "${TARGETDISCIDFILE}"

	# Write the header.
	echo "${DARTIST}
${DALBUM}
${CDYEAR}
${GENRE}
############################################################
" > "${TARGETDISCIDFILE}"



# Metallica
# Master Of Puppets
# 1986
# Metal
# ############################################################
#
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 01) Battery.mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 02) Master Of Puppets.mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 03) The Thing That Should Not Be.mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 04) Welcome Home (Sanitarium).mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 05) Disposable Heroes.mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 06) Leper Messiah.mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 07) Orion (Instrumental).mp3
# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 08) Damage, Inc..mp3



	# We should still be in: /var/lib/mpd/music/My CDs/Metallica/Master Of Puppets

	DBG_ECHO ""

	DBG_LS "."

	# Rename the tracks.
	DBG_ECHO ""
	DBG_ECHO "Renaming tracks..."

	for FILE in *.${OUTPUTTYPE}; do
		# If the file exists.
		if [ -e "${FILE}" ]; then

			TRK=$(echo ${FILE} | cut -d'-' -f1 -)
			NAM=$(echo ${FILE} | cut -d'-' -f2- -)

			SRC="${FILE}"
			DST="(${ARTISTFILE}) ${ALBUMFILE} - ${TRK}) ${NAM}"

			DBG_ECHO ""
			DBG_ECHO "The next file to rename is: ${FILE}"		# 01-Battery.mp3
			DBG_ECHO "SRC: ${SRC}"					# 01-Battery.mp3
			DBG_ECHO "DST: ${DST}"					# (Metallica) Master Of Puppets - 01) Battery.mp3
			DBG_ECHO "Trk: ${TRK}"					# 01
			DBG_ECHO "Nam: ${NAM}"					# Battery.mp3		With file extension
			DBG_ECHO "Nam: ${NAM%.mp3}"				# Battery		Without file extension

			mv -f -T "${SRC}" "${DST}"

			RV=${?}

			# If success.
			if [ 0 -eq "${RV}" ]; then
				DBG_ECHO "Changing file mode..."

				chmod 444 "${DST}"

				DBG_ECHO "Changing owner..."

				chown "${RIPPED_MUSIC_OWNER}" "${DST}"

				# Add the filename to the disc id playlist.
				# Metallica/Master Of Puppets/(Metallica) Master Of Puppets - 01) Battery.mp3
				DBG_ECHO "Adding: ${ARTISTFILE}/${ALBUMFILE}/${DST}"
				echo "${ARTISTFILE}/${ALBUMFILE}/${DST}" >> "${TARGETDISCIDFILE}"
			fi	# End of 'if [ 0 -eq "${RV}" ]; then'
		fi		# End of 'if [ -e "${FILE}" ]; then'
	done			# End of 'for FILE in *.mp3; do'

	# All the audio files have been renamed.

	# Move 'cover.jpg' cover file to the correct folder.
	# ie:
	#	From:	 /var/lib/mpd/music/My CDs/Metallica/cover.jpg
	#	To:	 /var/lib/mpd/music/My CDs/Metallica/Master Of Puppets/cover.jpg

	# If the cover file exists.
	if [ -f "albumart_backup/${ALBUMARTFILE}" ]; then
		# Move it into the ripped music files directory.
		DBG_ECHO ""
		DBG_ECHO "Moving cover artwork: ${ALBUMARTFILE}"
		mv "albumart_backup/$ALBUMARTFILE" "."

		# Remove the backup directory.
		DBG_ECHO "Removing the artwork backup directory: albumart_backup"
		rmdir --ignore-fail-on-non-empty "albumart_backup"
	fi

	# If the cover file exists.
	# If the cover file has been sucessfully moved.
	if [ -f "$OUTPUTDIR/${ARTISTFILE}/${ALBUMFILE}/${ALBUMARTFILE}" ]; then
		chmod 444 "$OUTPUTDIR/${ARTISTFILE}/${ALBUMFILE}/${ALBUMARTFILE}"
		chown "${RIPPED_MUSIC_OWNER}" "$OUTPUTDIR/${ARTISTFILE}/${ALBUMFILE}/${ALBUMARTFILE}"
	fi

	if [ -f "${TARGETDISCIDFILE}" ]; then
		# Write protect the cd disc id playlist.
		chmod 444 "${TARGETDISCIDFILE}"

		DBG_ECHO ""
		DBG_ECHO "The ripped disc id has been created: ${TARGETDISCIDFILE}"
	fi

	DBG_ECHO ""
	DBG_ECHO "All ${TRACKS} tracks should have been renamed."
	DBG_ECHO ""

	DBG_LS "${OUTPUTDIR}/${ARTISTFILE}/${ALBUMFILE}"

	DBG_ECHO ""
	# The ripped disc id file should have been created: /var/lib/mpd/music/My CDs/.Music CDs Ripped/520cd708 - Metallica - Master Of Puppets
	DBG_ECHO "The ripped disc id file should have been created: ${TARGETDISCIDFILE}"
	DBG_ECHO ""

	DBG_LS "${DISCIDHOMEDIR}"

	DBG_ECHO ""
fi	# End of 'if [ -d "${OUTPUTDIR}/${ARTISTFILE}/${ALBUMFILE}" ]; then'
}
